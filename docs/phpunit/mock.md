---
title: 测试替身
date: 2019-08-13 09:39:50
type: phpunit
layout: tag
---

<!-- {{$page.lastUpdated}} -->

# {{ $frontmatter.title }}

>&emsp;有时候测试的时候需要依赖很多其他的组件，外部的`mysql`,`redis`以及其他的服务，测试起来相当麻烦，如果在编写测试时无法使用（或选择不使用）实际的依赖组件（`DOC`），可以用测试替身来代替。测试替身不需要和真正的依赖组件有完全一样的的行为方式；它只需要提供和真正的组件同样的 `API` 即可，这样被测系统就会以为它是真正的组件！
>&emsp;PHPUnit提供的 `createStub($type)`、`createMock($type)` 和 `getMockBuilder($type)` 方法可以在测试中用来自动生成对象，此对象可以充当任意指定原版类型（接口或类名）的测试替身。在任何预期或要求使用原版类的实例对象的上下文中都可以使用这个测试替身对象来代替。
>&emsp;`createStub($type)` 和 `createMock($type)` 方法直接返回指定类型（接口或类）的测试替身对象实例。此测试替身的创建使用了最佳实践默认方案。原始类的 `__construct()` 和 `__clone()` 方法不会执行，且不对传递给测试替身的方法的参数进行克隆。如果这些默认值非你所需，可以用 `getMockBuilder($type)` 方法并使用流畅式接口来定制测试替身的生成过程。
>&emsp;在默认情况下，原版类的所有方法都会被替换为返回 `null` 的伪实现（其中不会调用原版方法）。使用诸如 `will($this->returnValue())` 之类的方法可以对这些伪实现在被调用时应当返回什么值做出配置。

## 一丶`Stubs(桩件，替换掉被测试系统所依赖的组件)`

:::demo 示例：想要上桩的类

```php

<?php
declare(strict_types=1);

namespace App\Infrastructure\Service\PlatformBar\Requests;

class PlatformBarService
{
    /**
     * 发送短信
     *
     * @param string $mobile 订单取票人手机号
     */
    public function sendMessage(string $mobile): array
    {
        return $this->platformRpcApiClient->request('Order/Sms/orderCancelVcodeSend', [
            'orderTel' => $mobile,
        ]);
    }
}
```
:::

:::demo 示例：对 `sendMessage` 方法进行上桩

```php

<?php

namespace HyperfTest\Domain\Logic\Order\Message;

use App\Infrastructure\Model\Order\Order;
use App\Infrastructure\Repository\Order\OrderRepository;
use App\Infrastructure\Service\PlatformBar\PlatformBarService;
use Hyperf\Testing\Client;
use Mockery\Exception;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestResult;

class OrderMessageTest extends TestCase
{
    protected Client $client;

    protected OrderRepository $orderRepository;

    protected PlatformBarService $platformBarService;

    protected string $key = 'platform_rpc_api';

    protected MockObject $stub;

    public function __construct(?string $name = null, array $data = [], $dataName = '')
    {
        parent::__construct($name, $data, $dataName);
        $this->client = make(Client::class);
        $this->orderRepository = make(OrderRepository::class);
        $this->platformBarService = make(PlatformBarService::class);
        $this->stub = $this->getMockBuilder(PlatformBarService::class)
            ->disableOriginalConstructor()   // 不走构造方法
            ->disableOriginalClone()   // 不克隆
            ->disallowMockingUnknownTypes() // 允许未知类型
            ->getMock();
    }

    public function createSerialOrderNo(): string
    {
        return '220512105107222843';
    }

    public function createResult(): TestResult
    {
        return parent::createResult(); // TODO: Change the autogenerated stub
    }

    /**
     * @test
     */
    public function serialOrderData(): Order
    {
        $serialOrderNo = $this->createSerialOrderNo();
        $order = $this->orderRepository->findBySerialOrderNo($serialOrderNo);
        $this->assertTrue(!is_null($order));
        return $order;
    }

    /**
     * @test
     * @depends serialOrderData
     */
    public function messageCode(Order $order){
        $this->assertTrue(is_string($order->user_mobile));

        $stub = $this->createStub(PlatformBarService::class);
        $stub->method('sendMessage')->willReturn('foo');

        $this->assertSame('foo', $stub->sendMessage($order->user_mobile));
    }

    /**
     * @test
     * @depends serialOrderData
     */
    public function exampleStub(Order $order)
    {
        $this->stub->method('sendMessage')->willReturn('foo');
        // 同上类似，但是更加强大
        $this->stub->method('sendMessage')->will($this->returnValue('foo'));

        // 返回参数跟传入参数相同
        $this->stub->method('sendMessage')->will($this->returnArgument(0));

        // 返回自身的对象引用
        $this->stub->method('sendMessage')->will($this->returnSelf());

        // 将参数和相应的返回值关联起来建立映射
        $this->stub->method('sendMessage')->will($this->returnValueMap([['a', 'b', 'c']]));

        // 需要返回计算得到的值而不是固定值
        // $stub->sendMessage('createSerialOrderNo')返回的结果就是createSerialOrderNo('createSerialOrderNo')方法返回的结果
        $this->stub->method('sendMessage')->will($this->returnCallback('createSerialOrderNo'));

        $this->assertSame('foo', $this->stub->sendMessage($order->user_mobile));
    }

    /**
     * @test
     * @depends serialOrderData
     */
    public function exampleOnConsecutiveCallsStub(Order $order)
    {
        $stub = $this->createStub(PlatformBarService::class);
        // 相比于建立回调方法，有一个更简单的选择是直接给出期望返回值的列表
        $stub->method('sendMessage')->will($this->onConsecutiveCalls(2, 3, 5, 7));

        $this->assertSame(2, $stub->sendMessage($order->user_mobile));
        $this->assertSame(3, $stub->sendMessage($order->user_mobile));
        $this->assertSame(5, $stub->sendMessage($order->user_mobile));
        $this->assertSame(7, $stub->sendMessage($order->user_mobile));
    }

    /**
     * 对方法的调用进行上桩，抛出异常
     *
     * @test
     * @depends serialOrderData
     */
    public function exampleException(Order $order)
    {
        $stub = $this->createStub(PlatformBarService::class);
        $stub->method('sendMessage')->will($this->throwException(new Exception()));

        $stub->sendMessage($order->user_mobile);
    }
}

```
:::

> 说明：添加`@test`可以表示这个方法是一个测试方法，添加`@depends serialOrderData`，表示改测试类的传参依赖于`depends`后面方法名的返回结果

---

## 二丶 `Mock Object (仿件对象)`


> &emsp;将对象替换为能验证预期行为（例如断言某个方法必会被调用）的测试替身的实践方法称为模仿（`mocking`）。
> &emsp;可以用仿件对象（`mock object`）“作为观察点来核实被测试系统在测试中的间接输出。通常，仿件对象还需要包括桩件的功能，因为如果测试尚未失败则仿件对象需要向被测系统返回一些值，但是其重点还是在对间接输出的核实上。因此，仿件对象远不止是桩件加断言，它是以一种从根本上完全不同的方式来使用的”（`Gerard Meszaros`）。

### `匹配器`


|        匹配器         |                    含义                    |
| :-------------------: | :----------------------------------------: |
|         any()         |        方法执行任意次数时匹配成功。        |
|        never()        |          方法从未执行时匹配成功。          |
|     atLeastOnce()     |        方法执行至少一次时匹配成功。        |
|        once()         |        方法执行恰好一次时匹配成功。        |
| exactly(int `$count`) |    方法执行恰好 `$count` 次时匹配成功。    |
|   at(int `$index`)    | 方法是第 `$index` 个执行的方法时匹配成功。 |

---

> 如一开始提到的，如果 `createStub()` 和 `createMock()` 方法在生成测试替身时所使用的默认值不符合你的要求，则可以通过 `getMockBuilder($type)` 方法来用流畅式接口定制测试替身的生成过程。以下是仿件生成器所提供的方法列表：

- `setMethods(array $methods)` 可以在仿件生成器对象上调用，来指定哪些方法将被替换为可配置的测试替身。其他方法的行为不会有所改变。如果调用 `setMethods(null)`，那么没有方法会被替换。
- 可以在仿件生成器对象上调用 `setMethodsExcept(array $methods)` 来指定哪些方法不被替换为可配置的测试替身，与此同时所有其他 `public` 方法都会被替换。`setMethods()` 的作用则相反。
- `setConstructorArgs(array $args)` 可用于向原版类的构造函数（默认情况下不会被替换为伪实现）提供参数数组。
- `setMockClassName($name)` 可用于指定生成的测试替身类的类名。
- `disableOriginalConstructor()` 参数可用于禁用对原版类的构造方法的调用。
- `disableOriginalClone()` 可用于禁用对原版类的克隆方法的调用。
- `disableAutoload()` 可用于在测试替身类的生成期间禁用 `__autoload()`。

---

:::demo 示例：模拟的`observer`类

```php
<?php


namespace HyperfTest\Cases;


class Observer
{
    public function update($argument)
    {
        //TODO:更新数据
    }

    public function reportError($errorCode, $errorMessage, Subject $subject)
    {
        // TODO:异常处理
    }
}

```
:::

:::demo 示例：模拟的 `subject` 类

```php
<?php
declare(strict_types=1);

namespace HyperfTest\Cases;

class Subject
{
    protected array $observers = [];
    protected string $name;

    public function __construct($name)
    {
        $this->name = $name;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function attach(Observer $observer)
    {
        $this->observers[] = $observer;
    }

    public function doSomething()
    {
        $this->notify('something');
    }

    public function doSomethingError()
    {
        foreach ($this->observers as $observer) {
            $observer->reportError(42, 'Something error happened', $this);
        }
    }

    protected function notify($argument)
    {
        foreach ($this->observers as $observer) {
            $observer->update($argument);
        }
    }
}

```
:::

:::demo 示例：对`subject`类进行模拟

```php
<?php

declare(strict_types=1);
/**
 * This file is part of Hyperf.
 *
 * @link     https://www.hyperf.io
 * @document https://hyperf.wiki
 * @contact  group@hyperf.io
 * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE
 */
namespace HyperfTest\Cases;

use PHPUnit\Framework\TestCase;
use stdClass;

/**
 * @internal
 * @coversNothing
 */
class SubjectTest extends TestCase
{
    /**
     * @test
     */
    public function observerUpdate(): void
    {
        // 为 [Observer] 创建仿件, 模仿 [update()] 方法
        $observer = $this->createMock(Observer::class);

        // 为 [update()] 方法建立预期, 只会以字符串 [someThing] 为参数调用一次
        // [with()] 方法可以携带任何数量的参数，对应于被模仿的方法的参数数量。可以对方法的参数指定更加高等的约束而不仅是简单的匹配。
        $observer->expects($this->once())
            ->method('update')
            ->with($this->equalTo('something'));

        // 建立 [Subject] 对象，并且将模拟的 [Observer] 对象附加在上面
        $subject = new Subject('subject');
        $subject->attach($observer);

        // 在 [Subject] 对象上调用 [doSomething()] 方法，我们预期会以字符串
        // [something] 调用模仿的 [Observer] 对象的 [update()] 方法。
        $subject->doSomething();
    }

    /**
     * 测试某个方法将会以特定数量的参数进行调用，并且对各个参数以多种方式进行约束
     *
     * @test
     */
    public function observerReportError()
    {
        $observer = $this->createMock(Observer::class);

        $observer->expects($this->once())
            ->method('reportError')
            ->with(
                $this->equalTo(42),
                $this->stringContains('Something error happened'),
                $this->anything()
            );

        $subject = new Subject('subject');
        $subject->attach($observer);

        $subject->doSomethingError();
    }

    /**
     * 方法可以接受任意多个数组作为参数，具体数量取决于欲测试的调用。每个数组都都是对被仿方法的相应参数的一组约束
     *
     * @test
     */
    public function functionCalledTwoTimesWithSpecificArguments()
    {
        $stdclass = $this->getMockBuilder(stdClass::class)
            ->addMethods(['set'])  // setMethods(['set'])方法已经被废弃
            ->getMock();

        $stdclass->expects($this->exactly(2))
            ->method('set')
            ->withConsecutive(
                [$this->equalTo('foo'), $this->greaterThan(0)],
                [$this->equalTo('bar'), $this->greaterThan(0)]
            );

        $stdclass->set('foo', 21);
        $stdclass->set('bar', 48);
    }

    /**
     * callback() 约束用来进行更加复杂的参数校验。此约束的唯一参数是一个 PHP 回调项（callback）。
     * 此 PHP 回调项接受需要校验的参数作为其唯一参数，并应当在参数通过校验时返回 true，否则返回 false
     *
     * @test
     */
    public function errorReportCallback()
    {
        $observer = $this->createMock(Observer::class);

        $observer->expects($this->once())
            ->method('reportError')
            ->with(
                $this->greaterThan(0),
                $this->stringContains('SomeThing'),
                $this->callback(
                    fn (Subject $subject) => is_callable([$subject, 'getName']) && $subject->getName() == 'subject'
                )
            );

        $subject = new Subject('subject');
        $subject->attach($observer);

        $subject->doSomethingError();
    }

    /**
     * 测试某个方法将会被调用一次，并且以某个特定对象作为参数。
     *
     * @test
     */
    public function specialObject()
    {
        $object = new stdClass();

        $stub = $this->getMockBuilder(stdClass::class)
            ->addMethods(['testMethod'])
            ->getMock();

        $stub->expects($this->once())
            ->method('testMethod')
            ->with($this->identicalTo($object));

        $stub->testMethod($object);
    }

    /**
     * 创建仿件对象时启用参数克隆
     *
     * @test
     */
    public function paramsClone()
    {
        $object = new stdClass();

        $stub = $this->getMockBuilder(stdClass::class)
            ->addMethods(['testMethod'])
            ->enableArgumentCloning()
            ->getMock();

        $stub->expects($this->once())
            ->method('testMethod')
            // 现在仿件会克隆参数，因此 identicalTo 约束会失败。
            ->with($object);

        $stub->testMethod($object);
    }
}

```
:::

## 三丶 `对特质（Trait）与抽象类进行模仿`

> &emsp;`getMockForTrait()` 方法返回一个使用了特定特质（trait）的仿件对象。给定特质的所有抽象方法将都被模仿。
> &emsp;`getMockForAbstractClass()` 方法返回一个抽象类的仿件对象。给定抽象类的所有抽象方法将都被模仿

---

:::demo 示例：模拟的`abstract`类

```php
<?php

declare(strict_types=1);
/**
 * This file is part of Hyperf.
 *
 * @link     https://www.hyperf.io
 * @document https://hyperf.wiki
 * @contact  group@hyperf.io
 * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE
 */
namespace HyperfTest\Cases\TestTrait;

abstract class AbstractClass
{
    public function creteMethod()
    {
        return $this->abstractMethod();
    }

    abstract public function abstractMethod();
}

```
:::

:::demo 示例：模拟`trait`类

```php
<?php

declare(strict_types=1);
/**
 * This file is part of Hyperf.
 *
 * @link     https://www.hyperf.io
 * @document https://hyperf.wiki
 * @contact  group@hyperf.io
 * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE
 */
namespace HyperfTest\Cases\TestTrait;

trait AbstractTrait
{
    public function creteMethod()
    {
        return $this->abstractMethod();
    }

    abstract public function abstractMethod();
}

```
:::

:::demo 示例：对`trait`和`abstract`类进行模拟

```php
<?php

declare(strict_types=1);
/**
 * This file is part of Hyperf.
 *
 * @link     https://www.hyperf.io
 * @document https://hyperf.wiki
 * @contact  group@hyperf.io
 * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE
 */
namespace HyperfTest\Cases\TestTrait;

use PHPUnit\Framework\TestCase;

/**
 * @internal
 * @coversNothing
 */
class TraitTestClass extends TestCase
{

    /**
     * @test
     */
    public function traitConcreteMethod()
    {
        $mock = $this->getMockForTrait(AbstractTrait::class);

        $mock->expects($this->any())
            ->method('abstractMethod')
            ->will($this->returnValue(true));

        $this->assertTrue($mock->creteMethod());
    }

    /**
     * @test
     */
    public function abstractConcreteMethod()
    {
        $mock = $this->getMockForAbstractClass(AbstractClass::class);

        $mock->expects($this->any())
            ->method('abstractMethod')
            ->will($this->returnValue(true));

        $this->assertTrue($mock->creteMethod());
    }
}

```
:::

## 四丶 `Web 服务（Web Services）进行上桩或模仿`


>&emsp;当应用程序需要和 `web` 服务进行交互时，会想要在不与 `web` 服务进行实际交互的情况下对其进行测试。为了给 web 服务创建桩件或仿件，可以像使用 `getMock()`（见上文）那样使用 `getMockFromWsdl()`。唯一的区别是 `getMockFromWsdl()` 所返回的桩件或者仿件是基于以 `WSDL` 描述的 `web` 服务，而 `getMock()` 返回的桩件或者仿件是基于 `PHP` 类或接口的。
>&emsp;展示了如何用 `getMockFromWsdl()` 来对（例如）`GoogleSearch.wsdl` 中描述的 web 服务上桩。

---

:::demo 示例：对`googleSearch`进行上桩

```php
<?php

declare(strict_types=1);
/**
 * This file is part of Hyperf.
 *
 * @link     https://www.hyperf.io
 * @document https://hyperf.wiki
 * @contact  group@hyperf.io
 * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE
 */
namespace HyperfTest\Cases\TestTrait;

use PHPUnit\Framework\TestCase;
use stdClass;

/**
 * @internal
 * @coversNothing
 */
class GoogleTest extends TestCase
{
    /**
     * @test
     */
    public function search(): void
    {
        $googleSearch = $this->getMockFromWsdl(
            'GoogleSearch.wsdl',
            'GoogleSearch'
        );

        $directoryCategory                   = new stdClass();
        $directoryCategory->fullViewableName = '';
        $directoryCategory->specialEncoding  = '';

        $element                            = new stdClass();
        $element->summary                   = '';
        $element->URL                       = 'https://phpunit.de/';
        $element->snippet                   = '...';
        $element->title                     = '<b>PHPUnit</b>';
        $element->cachedSize                = '11k';
        $element->relatedInformationPresent = true;
        $element->hostName                  = 'phpunit.de';
        $element->directoryCategory         = $directoryCategory;
        $element->directoryTitle            = '';

        $result                             = new stdClass();
        $result->documentFiltering          = false;
        $result->searchComments             = '';
        $result->estimatedTotalResultsCount = 3.9000;
        $result->estimateIsExact            = false;
        $result->resultElements             = [$element];
        $result->searchQuery                = 'PHPUnit';
        $result->startIndex                 = 1;
        $result->endIndex                   = 1;
        $result->searchTips                 = '';
        $result->directoryCategories        = [];
        $result->searchTime                 = 0.248822;

        $googleSearch->expects($this->any())
            ->method('googleSearch')
            ->will($this->returnValue($result));

        /*
         * $googleSearch->doGoogleSearch() 现在会返回桩结果，
         * 并不会调用 web 服务的 doGoogleSearch() 方法。
         */
        $this->assertEquals(
            $result,
            $googleSearch->googleSearch(
                '00000000000000000000000000000000',
                'PHPUnit',
                0,
                1,
                false,
                '',
                false,
                '',
                '',
                ''
            )
        );
    }
}

```
:::

:::demo 插件
```php

'@vuepress/active-header-links', // 页面滚动时自动激活侧边栏链接的插件
    '@vuepress/back-to-top', // 返回顶部插件
    '@vuepress/medium-zoom', // 图片预览插件
    '@vuepress/nprogress', //页面顶部进度条
    ['@vuepress/active-header-links', {
      sidebarLinkSelector: '.sidebar-link',
      headerAnchorSelector: '.header-anchor'
    }]  // 页面滚动时自动激活侧边栏链接的插件
    ['vuepress-plugin-code-copy', true], // 代码复制
    [
      '@vuepress/plugin-search',
      {
        locales: {
          '/': {
            placeholder: 'Search',
          },
          '/zh/': {
            placeholder: '搜索',
          },
        },
      },
    ],

```
:::